<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>单例模式</title>
</head>
<body>

</body>
<script>
   // 实现单例模式
   // var Singleton = function (name) {
   //   this.name = name
   //   this.instance = null
   // }
   //
   // Singleton.prototype.getName = function () {
   //   console.log(this.name)
   // }
   //
   // Singleton.getInstance = function (name) {
   //   if (!this.instance) {
   //     this.instance = new Singleton(name)
   //   }
   //   return this.instance
   // }
   //
   // var a = Singleton.getInstance('Ken1')
   // var b = Singleton.getInstance('Ken2')
   // a.getName() // Ken1
   // b.getName() // Ken1
   // console.log(a === b)
   /*
   我们通过 Singleton.getInstance 来获取 Singleton 类的唯一对象，这种方式相对简单，但有一个问题，就是增加了这个类的“不透明性”，Singleton 类的使用者必须知道这是一个单例类， 跟以往通过 new XXX 的方式来获取对象不同，这里偏要使用 Singleton.getInstance 来获取对象。
    */


   // 用代理实现单例模式 单一职责原则
   var CreateDiv = function (html) {
     this.html = html
     this.init
   }

   CreateDiv.prototype.init = function () {
     var div = document.createElement('div')
     div.innerHTML = this.html
     document.body.appendChild(div)
   }

   // 接下来 引入代理类 proxySingletonCreateDiv
   var ProxySingletonCreateDiv = (function () {
     var instance
     return function (html) {
       if (!instance) {
         instance = new CreateDiv(html)
      }
      return instance
    }
   })()

   var a = new ProxySingletonCreateDiv('sven1')
   var b = new ProxySingletonCreateDiv('sven2')
   console.log(a === b)
   /*
   通过引入代理类的方式，我们同样完成了一个单例模式的编写，跟之前不同的是，现在我们 把负责管理单例的逻辑移到了代理类 proxySingletonCreateDiv 中。这样一来，CreateDiv 就变成了 一个普通的类，它跟 proxySingletonCreateDiv 组合起来可以达到单例模式的效果。
    */


   // 惰性单例 惰性单例指的是在需要的时候才创建对象实例
   // 我们将以 WebQQ 的登录浮窗为例，介绍与全局变量结合实现惰性的单例 浮窗节点只会创造一次 并且点击登录的时候才会创建
   // var createLoginLayer = (function () {
   //   var div
   //   return function () {
   //     if (!div) {
   //       div = document.createElement('div')
   //       div.innerHTML = '我是登录浮窗'
   //       div.style.display = 'none'
   //       document.body.appendChild(div)
   //     }
   //     return div
   //   }
   // })()
   // document.getElementById('loginBtn').onclick = function () {
   //   var loginLayer = createLoginLayer()
   //   loginLayer.style.display = 'block'
   // }


   // 通用的惰性单例
   /*
   上面那段代码仍然是违反单一职责原则的，创建对象和管理单例的逻辑都放在 createLoginLayer 对象内部。
   如果我们下次需要创建页面中唯一的 iframe，或者 script 标签，用来跨域请求数据，就 必须得如法炮制，把 createLoginLayer 函数几乎照抄一遍
   现在我们就把如何管理单例的逻辑从原来的代码中抽离出来，这些逻辑被封装在 getSingle 函数内部，创建对象的方法 fn 被当成参数动态传入 getSingle 函数
    */
   var getSingle = function (fn) {
     var result
     return function () {
       return result || (result = fn.apply(this, arguments))
     }
   }

   /*
   接下来将用于创建登录浮窗的方法用参数 fn 的形式传入 getSingle，我们不仅可以传入 createLoginLayer，还能传入 createScript、createIframe、createXhr 等。之后再让 getSingle 返回 一个新的函数，并且用一个变量 result 来保存 fn 的计算结果。result 变量因为身在闭包中，它永远不会被销毁。在将来的请求中，如果 result 已经被赋值，那么它将返回这个值。代码如下:
    */
   var createLoginLayer = function () {
     var div = document.createElement('div')
     div.innerHTML = '我是登录浮窗'
     div.style.display = 'none'
     document.body.appendChild(div)
     return div
   }
   var createSingleLoginLayer = getSingle(createLoginLayer)
   document.getElementById( 'loginBtn' ).onclick = function () {
     var loginLayer = createSingleLoginLayer()
     loginLayer.style.display = 'block'
   }

   // 下面我们再试试创建唯一的 iframe 用于动态加载第三方页面:
   var createSingleIframe = getSingle( function(){
     var iframe = document.createElement ( 'iframe' )
     document.body.appendChild( iframe )
     return iframe
   })
   document.getElementById( 'loginBtn' ).onclick = function(){
     var loginLayer = createSingleIframe()
     loginLayer.src = 'http://baidu.com'
   }
   // 在这个例子中，我们把创建实例对象的职责和管理单例的职责分别放置在两个方法里，这两个方法可以独立变化而互不影响，当它们连接在一起的时候，就完成了创建唯一实例对象的功能， 看起来是一件挺奇妙的事情
    /*
    在 getSinge 函数中，实际上也提到了闭包和高阶函数的概念。单例模式是一种简单但非常实 用的模式，特别是惰性单例技术，在合适的时候才创建对象，并且只创建唯一的一个。更奇妙的 是，创建对象和管理单例的职责被分布在两个不同的方法中，这两个方法组合起来才具有单例模式的威力
     */
</script>
</html>
