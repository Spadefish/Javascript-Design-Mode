<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>策略模式</title>
</head>
<body>

</body>
<script>
    /*
    策略模式的定义是:定义一系列的算法，把它们一个个封装起来，并且使它们可以相互替换
     */

    /*
    eg: 使用策略模式计算奖金
    很多公司的年终奖是根据员工的工资基数和年底绩效情况来发放的。
    例如，绩效为 S 的人年 终奖有 4 倍工资，绩效为 A 的人年终奖有 3 倍工资，而绩效为 B 的人年终奖是 2 倍工资
     */

    // 最初代码实现
    // var calculateBonus = function (performanceLevel, salary) {
    //   if ( performanceLevel === 'S' ){ return salary * 4;
    //   }
    //   if ( performanceLevel === 'A' ){ return salary * 3;
    //   }
    //   if ( performanceLevel === 'B' ){ return salary * 2;
    //   }
    // }
    //
    // calculateBonus( 'B', 20000 ); // 输出:40000
    // calculateBonus( 'S', 6000 ); // 输出:24000
    /*
    可以发现，这段代码十分简单，但是存在着显而易见的缺点。
    1, calculateBonus 函数比较庞大，包含了很多 if-else 语句，这些语句需要覆盖所有的逻辑分支
    2, calculateBonus 函数缺乏弹性，如果增加了一种新的绩效等级 C，或者想把绩效 S 的奖金 系数改为 5，那我们必须深入 calculateBonus 函数的内部实现，这是违反开放封闭原则的
    3, 算法的复用性差，如果在程序的其他地方需要重用这些计算奖金的算法呢?我们的选择只有复制和粘贴
     */


    // 使用组合函数重构代码
    /*
    一般最容易想到的办法就是使用组合函数来重构代码，我们把各种算法封装到一个个的小函数里面，
    这些小函数有着良好的命名，可以一目了然地知道它对应着哪种算法，它们也可以被复用在程序的其他地方。代码如下:
     */
    var performanceS = function (salary) {
      return salary * 4
    }
    var performanceA = function (salary) {
      return salary * 3
    }
    var performanceB = function (salary) {
      return salary * 2
    }

    var calculateBonus = function (performanceLevel, salary) {
      if (performanceLevel === 'S') {
        return performanceS(salary)
      }
      if (performanceLevel === 'A') {
        return performanceA(salary)
      }
      if (performanceLevel === 'B') {
        return performanceB(salary)
      }
    }

    calculateBonus( 'A' , 10000 ); // 输出:30000
    /*
    目前，我们的程序得到了一定的改善，但这种改善非常有限，我们依然没有解决最重要的问题:calculateBonus 函数有可能越来越庞大，而且在系统变化的时候缺乏弹性
     */


    // 使用策略模式重构代码
    /*
    策略模式的目的就是将算法的使用与算法的实现分离开来
     */
    var strategies = {
      'S': function (salary) {
        return salary * 4
      },
      'A': function (salary) {
        return salary * 3
      },
      'B': function (salary) {
        return salary * 2
      }
    }

    var calculateBonus = function (level, salary) {
      return strategies[level](salary)
    }
    console.log( calculateBonus('S', 20000 )) // 80000
    console.log( calculateBonus('A', 10000 )) // 30000


    // 表单校验的第一个版本

</script>
</html>
