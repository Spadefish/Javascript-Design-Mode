<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>表单校验</title>
</head>
<body>
<form id="registerForm">
    请输入用户名: <input type="text" name="userName"/>
    请输入密码: <input type="text" name="password"/>
    请输入手机号码:<input type="text" name="phoneNumber"/>
    <button id="button">提交</button>
</form>
</body>
<script>
  /***********************策略对象**************************/
  var strategies = {
    isNonEmpty: function (value, errorMsg) {
      if (value === '') {
        return errorMsg
      }
    },
    minLength: function (value, length, errorMsg) {
      if (value.length < length) {
        return errorMsg
      }
    },
    isMobile: function (value, errorMsg) {
      if (!/(^1[0-9]{10}$)/.test(value)) {
        return errorMsg
      }
    }
  }

  /***********************Validator 类**************************/
  var Validator = function () {
    this.cache = []
  }
  Validator.prototype.add = function (dom, rules) {
    var self = this
    for (var i = 0, rule; rule = rules[i++];) {
      (function (rule) {
        var strategyAry = rule.strategy.split(':')
        var errorMsg = rule.errorMsg
        self.cache.push(function () {
          var strategy = strategyAry.shift()
          strategyAry.unshift(dom.value)
          strategyAry.push(errorMsg)
          console.log('strategyAry===', strategyAry)
          return strategies[strategy].apply(self, strategyAry)
        })
      })(rule)
    }
  }

  Validator.prototype.start = function () {
    for (var i = 0, validatorFunc; validatorFunc = this.cache[i++];) {
      var errorMsg = validatorFunc()
      if (errorMsg) {
        return errorMsg
      }
    }
  }

  /***********************客户调用代码**************************/
  var registerForm = document.getElementById('registerForm')

  var validataFunc = function () {
    var validator = new Validator()
    validator.add(registerForm.userName, [{
      strategy: 'isNonEmpty',
      errorMsg: '用户名不能为空'
    }, {
      strategy: 'minLength:6',
      errorMsg: '用户名长度不能小于 6 位'
    }])
    validator.add(registerForm.password, [
      {
        strategy: 'minLength:6',
        errorMsg: '密码长度不能小于 6 位'
      }
    ])
    validator.add(registerForm.phoneNumber, [
      {
        strategy: 'isMobile',
        errorMsg: '手机号码格式不正确'
      }
    ])
    console.log('validator.cache ===', validator.cache)
    var errorMsg = validator.start()
    return errorMsg
  }

  document.getElementById('button').onclick = function () {
    var errorMsg = validataFunc()
    if (errorMsg) {
      console.log(errorMsg)
      return false
    }
  }

  /*
  *实际上在 JavaScript 这种将函数作为一等对象的语言里，策略模式已经融入到了语言本身 当中，我们经常用高阶函数来封装不同的行为，并且把它传递到另一个函数中。当我们对这些函 数发出“调用”的消息时，不同的函数会返回不同的执行结果。在 JavaScript 中，“函数对象的多态性”来得更加简单。
   */

  // 在前面的学习中，为了清楚地表示这是一个策略模式，我们特意使用了 strategies 这个名字。如果去掉 strategies，我们还能认出这是一个策略模式的实现吗?代码如下:
  var S = function (salary) {
    return salary * 4
  }
  var A = function (salary) {
    return salary * 3
  }
  var B = function (salary) {
    return salary * 2
  }
  var calculateBonus = function (func, salary) {
    return func(salary)
  }
  calculateBonus(S, 10000) // 输出:40000

  /*
  本章我们既提供了接近传统面向对象语言的策略模式实现，也提供了更适合 JavaScript 语言 的策略模式版本。在 JavaScript 语言的策略模式中，策略类往往被函数所代替，这时策略模式就 成为一种“隐形”的模式。尽管这样，从头到尾地了解策略模式，不仅可以让我们对该模式有更加透彻的了解，也可以使我们明白使用函数的好处。
   */
</script>
</html>
